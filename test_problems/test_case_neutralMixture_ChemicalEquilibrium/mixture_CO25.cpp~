#include <time.h>
#include <iostream>
#include <vector>
#include <cantera/Cantera.h>
#include <cantera/zerodim.h>
//#include <cantera/IdealGasMix.h>
	#include <cantera/thermo/ThermoPhase.h>			//kernel
	#include <cantera/thermo/ThermoFactory.h>		//kernel
#include <cantera/equilibrium.h>
#include <fstream>
#include <iomanip>
#include <../../cantera/src/transport/MMCollisionInt.h>
#include <../../cantera/include/cantera/transport/TransportParams.h> 
//	#include <cantera/thermo/Elements.h>			//kernel
	#include <cantera/transport/TransportFactory.h>		//kernel
#include <string>
// #include <cantera/transport/MixTransport.h> 


using namespace Cantera;
using namespace std;


//clock_t begin = clock();
//code_to_time();


void equil_demo() {

	ofstream f("speciesName.txt");

	ofstream f10("molarFractions_VS_Temperature.txt");
	ofstream f10e("electronMolarFraction.txt");


	ofstream f15("mixture_specific_enthalpy_internalEnergy_entropy_Cp.txt");
	ofstream f16("mixture_molar_enthalpy_entropy.txt");

	ofstream fa("partialMolarCp.txt");
	ofstream fa2("partialMolarEnthalpies.txt");

	ofstream fb("speciesMoleFractionGradient.txt");
	ofstream fd("qReactive_Mixture.txt");
	ofstream fe("thermalConductivity_Mixture.txt");
        ofstream fe2("electronTranslationalThCond.txt");
        ofstream fe3("translationalThCond_Mixture.txt");
	ofstream ff("viscosity_Mixture.txt");
        ofstream ffGY("viscosity_MixtureGY.txt");
	ofstream sV("speciesViscosity.txt");


	ofstream qR("species_qReactive.txt");
/*
	ofstream qj("speciesDiffusiveMassFluxes.txt");
        ofstream qj2("speciesDiffusiveMassFluxesSM.txt");
        ofstream qj3("speciesDiffusiveMassFluxesSM_Eamb.txt");
*/

        ofstream qj("speciesDiffusiveMassFluxes_GMRES.txt");
        ofstream qj2("speciesDiffusiveMassFluxesSM_GMRES.txt");
        ofstream qj3("speciesDiffusiveMassFluxesSM_CG_Eamb.txt");

	ofstream ci("collisionIntegral_Omega11.txt");
	ofstream bdc("binaryDiffusionCoefficients_CO2.txt");
	ofstream bdc1("binaryDiffusionCoefficients_CO.txt");
	ofstream bdc2("binaryDiffusionCoefficients_O.txt");
	ofstream bdc3("binaryDiffusionCoefficients_C.txt");
	ofstream d1("mixtureAverageDiffCoeff.txt");
	ofstream d2("mixtureAverageDiffCoeff_mass.txt");
	ofstream d3("mixtureAverageDiffCoeff_mol.txt");

	ofstream m1("massConstrain.txt");
	ofstream ch1("chargeConstrain.txt");
					
//	double T_in = 300;		// Initial Temperature (K)
//	double T_fin = 10000;		// Final Temperature (K)
//	double T=T_in;           	// Initialization of Temperature
//	double delta = 100;		// delta_T: increment for Temperature
	double eps=0.00001;       	// epsilon (for finite difference computation)
        double epsP=1+eps;      	// epsilonP (for finite difference computation)
//	double T2=epsP*T;               // Initialize temperature T2 (for gradient computation)
	int a = 20;			// offset for external document
	int a2= 25;			// second offset for external document



	ThermoPhase* gas = newPhase("gri_CO25.xml","gri30_mix");	// Generate new phase
	ThermoPhase* gas2 = newPhase("gri_CO25.xml","gri30_mix");	// Generate new phase for grad_X calculation

//        ThermoPhase* gas = newPhase("gri30_highT_ionized.xml","gri30_mix");        // Generate new phase
//        ThermoPhase* gas2 = newPhase("gri30_highT_ionized.xml","gri30_mix");       // Generate new phase for grad_X calculation


	Transport* tr = newTransportMgr("Mix", gas);		// Transport manager for gas (transport properties calculation)
	int	numSpecies = gas->nSpecies();		// Number of species in the mixture
	string	nameSpecies[numSpecies];		// to define the vector for Name of species

	double cp[numSpecies];				// to create a vector (called cp) for the molar heat capacities

	double weights[numSpecies];			// to create a vector (called weights) for the molecular weights of each species
        gas->getMolecularWeights(weights);		// to save in weights the molecular weights

        double MolarEnthalpies[numSpecies];		// to create a vector (called MolarEnthalpies) for the molar enthalpies of each species

	double JDiff[numSpecies];			// to create a vector (called JDiff) for the species diffusive mass fluxes [kg/m2/s]
        double JDiff_SM[numSpecies];                    // to create a vector (called JDiff) for the species diffusive mass fluxes [kg/m2/s]
	double JDiff_Eamb[numSpecies];

	double grad_T[1]={1};				// to create a vector (N.B. nDim=1)  for Temperature Gradient (N.B. isotropy: no preferential directions)	

        double grad_X[numSpecies];			// to create a vector for Gradients of the mole fraction
        for (int b=0; b<numSpecies; b++)		// Initialize grad_T and grad_X
        {grad_X[b]=1;}

	double qReactiveSpecies[numSpecies];		// to create a vector for the species qReactive (qReactive_k = Jdiff_k * MassEnthalpy_k)
	double qReactive=0;             		// initialize qReactive (qReactive = Sum_k qReactive_k)


	double mixAverDiffCoeff[numSpecies];
	double mixAverDiffCoeff_mass[numSpecies];
	double mixAverDiffCoeff_mole[numSpecies];
	double binDiffCoeff[numSpecies*numSpecies];            // to create a vector for CO2 binary diffusion coefficients

	double massConstrain = 0;
        double chargeConstrain = 0;


	double specVisc[numSpecies];			// to create a vector (called specVisc) for the species viscosities [Pa*s]

	// Headings for external files
	f10 << setw(a) << left << "T[K]";
        f15 << setw(a2) << left << "T[K]";
        f15 << setw(a2) << left << "Enthalpy[J/kg]" << setw(a2) << left << "InternalEnergy[J/kg]" << setw(a2) << left << "Entropy[J/(kg*K)]" << setw(a2) << left << "Cp[J/(kg*K)]" << endl;
	f16 << setw(a2) << left << "T[K]";
        f16 << setw(a2) << left << "Enthalpy[J/kmol]" << setw(a2) << left << "Entropy[J/(kmol*K)]" << endl;
        fa  << setw(a) << left << "T[K]";
	fa2 << setw(a) << left << "T[K]";
	fb  << setw(a) << left << "T[K]";
	ci  << setw(a) << left << "T[K]" << setw(a2) << left << "omega11" << endl;
	bdc  << setw(a) << left << "T[K]";
	bdc1  << setw(a) << left << "T[K]";
	bdc2  << setw(a) << left << "T[K]";
	bdc3  << setw(a) << left << "T[K]";
	d1  << setw(a) << left << "T[K]";
	d2  << setw(a) << left << "T[K]";
	d3  << setw(a) << left << "T[K]";

	qR << setw(a) << left << "T[K]";
	qj << setw(a) << left << "T[K]";
        qj2 << setw(a) << left << "T[K]";
        qj3 << setw(a) << left << "T[K]";

	sV << setw(a) << left << "T[K]";

	for (int b1=0; b1<numSpecies; b1++)
        {
		nameSpecies[b1] = gas->speciesName(b1); 					// to save in nameSpecies the name of each species
                f   << setw(a) << left << "The species named " << setw(a-10) << left << b1 << setw(a-10) << left << " is: " << setw(a-10) << left << nameSpecies[b1];
		f   << setw(a-10) << left << "molecular weight: " << setw(a) << left << weights[b1] << endl;
                f10 << setw(a) << left << nameSpecies[b1];
                fa  << setw(a) << left << nameSpecies[b1];
		fa2 << setw(a) << left << nameSpecies[b1];
		fb  << setw(a) << left << nameSpecies[b1];
		bdc  << setw(a) << left << nameSpecies[b1];
		bdc1  << setw(a) << left << nameSpecies[b1];
		bdc2  << setw(a) << left << nameSpecies[b1];
		bdc3  << setw(a) << left << nameSpecies[b1];
		d1  << setw(a) << left << nameSpecies[b1];
		d2  << setw(a) << left << nameSpecies[b1];
		d3  << setw(a) << left << nameSpecies[b1];

		qR << setw(a) << left << nameSpecies[b1];		
                qj << setw(a) << left << nameSpecies[b1];
                qj2 << setw(a) << left << nameSpecies[b1];
                qj3 << setw(a) << left << nameSpecies[b1];

		sV << setw(a) << left << nameSpecies[b1];

	}
        f10 << endl;
	fa  << endl;
	fa2 << endl;
	fb  << endl;
	bdc  << endl;
	bdc1  << endl;
	bdc2  << endl;
	bdc3  << endl;
	d1  << endl;
	d2  << endl;
	d3  << endl;
	qR << endl;
	qj << endl;
        qj2 << endl;
        qj3 << endl;

	sV << endl;




//const int sizeT = 298;
const int sizeEamb = 2;
//const int sizeSp = 23;
//const int sizeSpCant = 64;
//double x[sizeSp];
double y[sizeEamb];			// read Electrinc field as a function of temperature


//ifstream file("Temp_X_GradX.dat", ios::in);
ifstream file2("E_Amb.txt", ios::in);
//ifstream file2("E_Amb2.txt", ios::in);

for (int i=0; i<298; i++)
{


for (int i=0; i<sizeEamb; i++)
        {file2 >> y[i];}

/*
for (int i=0; i<sizeSp; i++)
        {       file >> x[i];

//                cout << x[i] << "   ";
        }
*/

double E_ambipolar = y[1];
double T = y[0];
double T2=epsP*T;               // Initialize temperature T2 (for gradient computation)


/*
double composition[sizeSpCant]={};

                // if electron is at last position
                composition[63] = x[1];        // electron

                composition[30] = x[2];         // N

                composition[2] = x[3];          // O

                composition[47] = x[4];         // N2

                composition[35] = x[5];         // NO

                composition[3] = x[6];          // O2                

                composition[55] = x[7];         // N2+

                composition[58] = x[8];         // NO+

                composition[54] = x[9];         // N+

                composition[57] = x[10];        // O2+

                composition[56] = x[11];        // O+


double gradient[sizeSpCant]={};


                // if electron is at last position
                gradient[63] = x[12];        // electron

                gradient[30] = x[13];         // N

                gradient[2] = x[14];          // O

                gradient[47] = x[15];         // N2

                gradient[35] = x[16];         // NO

                gradient[3] = x[17];          // O2                

                gradient[55] = x[18];         // N2+

                gradient[58] = x[19];         // NO+

                gradient[54] = x[20];         // N+

                gradient[57] = x[21];        // O2+

                gradient[56] = x[22];        // O+
*/



// vector x has zero as mole fraction for every species except for the ones coming from the Air11file

		T2=epsP*T;       	// Set T2 for computations
		qReactive=0;            // reset qReactive for computations

//                gas->setState_TPX(T, 1.0*OneAtm,"N2:0.79, O2:0.21");      // Set the state for the Mixture
//                gas2->setState_TPX(T2, 1.0*OneAtm,"N2:0.79, O2:0.21");    // Set the state for the Mixture gas2 (for grad_X calculation)


                gas->setState_TPX(T, 1.0*OneAtm,"C:0.333, O:0.667");      // Set the state for the Mixture
                gas2->setState_TPX(T2, 1.0*OneAtm,"C:0.333, O:0.667");    // Set the state for the Mixture gas2 (for grad_X calculation)


/*
                gas->setState_TPX(T, 1.0*OneAtm,"CO:1.0, CO2:1.0, O2:1.0, C:1.0, O:1.0");      // Set the state for the Mixture
                gas2->setState_TPX(T2, 1.0*OneAtm,"CO:1.0, CO2:1.0, O2:1.0, C:1.0, O:1.0");    // Set the state for the Mixture gas2 (for grad_X calculation)
*/


// no need for equilibrate if I introduce the concentration
		equilibrate(*gas, "TP");                                                 	// Equilibrium
		equilibrate(*gas2, "TP");						 	// Equilibrium


		tr->getMixDiffCoeffs(mixAverDiffCoeff);
		tr->getMixDiffCoeffsMole(mixAverDiffCoeff_mole);
		tr->getMixDiffCoeffsMass(mixAverDiffCoeff_mass);


		gas->getPartialMolarCp(cp);                                             	// to save in cp the heat capacities
		gas->getPartialMolarEnthalpies(MolarEnthalpies);        			// to save in MolarEnthalpies the molar enthalpies
		tr->getSpeciesViscosities(specVisc);						// to save in specVisc the species viscosities
		tr->getBinaryDiffCoeffs(numSpecies, binDiffCoeff);

		// Save in grad_X the Mole Fraction Gradients corresponding to a unitary Temperature Gradiend (P.S. constant pressure)
		for(int c=0; c<numSpecies; c++)
                {
                	grad_X[c]=(gas2->moleFraction(c) - gas->moleFraction(c))/(T2-T);
              	}


         	// Save in the vector JDiff the species diffusive mass fluxes [kg/m2/s]
             	tr->getSpeciesFluxes(1, grad_T, numSpecies, grad_X, numSpecies, JDiff);
		tr->getSpeciesFluxesSM(1, grad_T, numSpecies, grad_X, numSpecies, JDiff_SM);
                tr->getSpeciesFluxesSMEamb(1, grad_T, numSpecies, grad_X, numSpecies, E_ambipolar, JDiff_Eamb);


		massConstrain = 0;
		chargeConstrain = 0;
		for(size_t MC=0; MC<gas->nSpecies(); MC++)
                {
			massConstrain = massConstrain + JDiff[MC];

			if ( ( MC == gas->speciesIndex("N+") ) or ( MC == gas->speciesIndex("O+") ) or ( MC == gas->speciesIndex("N2+") ) or ( MC == gas->speciesIndex("O2+") )
				 or ( MC == gas->speciesIndex("NO+") )	)
				{ chargeConstrain = chargeConstrain + JDiff[MC]*1; }
			else if ( ( MC == gas->speciesIndex("E") ) )
				{ chargeConstrain = chargeConstrain + JDiff[MC]*(-1);}
		}

		qR << setw(a) << left << T;
		qj << setw(a) << left << T;
                qj2 << setw(a) << left << T;
                qj3 << setw(a) << left << T;


		// Compute the qReactive [J/m2/s] for each species and the total qReactive (N.B. since grad_T=1, qReactive coincide with the reactive term of thermal conductivity)
           	for(int c1=0; c1<numSpecies; c1++)
               	{
              		qReactiveSpecies[c1] = JDiff_SM[c1]*MolarEnthalpies[c1]/weights[c1];
			qReactive = qReactive - qReactiveSpecies[c1];

			qR << setw(a) << left << qReactiveSpecies[c1];

			qj << setw(a) << left << JDiff[c1];
                        qj2 << setw(a) << left << JDiff_SM[c1];
                        qj3 << setw(a) << left << JDiff_Eamb[c1];

		}
			
		// For species: to write the external files
		f10 << setw(a) << left << T;
		fa  << setw(a) << left << T;
		fa2 << setw(a) << left << T;
		fb  << setw(a) << left << T;
		bdc << setw(a) << left << T;
		bdc1 << setw(a) << left << T;
		bdc2 << setw(a) << left << T;
		bdc3 << setw(a) << left << T;
		d1 << setw(a) << left << T;
		d2 << setw(a) << left << T;
		d3 << setw(a) << left << T;

		sV << setw(a) << left << T;

		for (int c2=0; c2<numSpecies; c2++)
		{
			f10 << setw(a) << left << gas->moleFraction(c2);
			fa  << setw(a) << left << cp[c2];
			fa2 << setw(a) << left << MolarEnthalpies[c2];

				fb  << setw(a) << left << grad_X[c2];

			d1 << setw(a) << left << mixAverDiffCoeff[c2];
	                d2 << setw(a) << left << mixAverDiffCoeff_mass[c2];
        	        d3 << setw(a) << left << mixAverDiffCoeff_mole[c2];

			sV << setw(a) << left << specVisc[c2];

		}
		for (int c3=gas->speciesIndex("CO2"); c3<(numSpecies*numSpecies); c3=c3+numSpecies)	// write binary diffusion coefficients for CO2
		{
			bdc  << setw(a) << left << binDiffCoeff[c3];
		}
		for (int c4=gas->speciesIndex("CO"); c4<(numSpecies*numSpecies); c4=c4+numSpecies)	// write binary diffusion coefficients for CO
                {
                        bdc1  << setw(a) << left << binDiffCoeff[c4];
                }
		for (int c5=gas->speciesIndex("O"); c5<(numSpecies*numSpecies); c5=c5+numSpecies)      // write binary diffusion coefficients for O
                {
                        bdc2  << setw(a) << left << binDiffCoeff[c5];
                }
		for (int c6=gas->speciesIndex("C"); c6<(numSpecies*numSpecies); c6=c6+numSpecies)
 // write binary diffusion coefficients for C
                {
                        bdc3  << setw(a) << left << binDiffCoeff[c6];
                }


		// electron molar fraction
		f10e << setw(a) << left << T << setw(a) << left << gas->moleFraction(gas->speciesIndex("E")) << endl;



		f10 << endl;
		fa  << endl;
		fa2 << endl;
		fb  << endl;
		bdc  << endl;
		bdc1  << endl;
		bdc2  << endl;
		bdc3  << endl;
		d1  << endl;
                d2  << endl;
                d3  << endl;

		qR << endl;
		qj << endl;
                qj2 << endl;
                qj3 << endl;

		sV << endl;
		// For mixture: to write the external files
		fd  << setw(a) << left << T << qReactive << endl;
		fe  << setw(a) << left << T << tr->thermalConductivity() << endl;
//                fe2  << setw(a) << left << T << tr->ElectronTranslationalThermalConductivity() << endl;
                fe3  << setw(a) << left << T << tr->translationalThermalConductivity() << endl;
		ff  << setw(a) << left << T << tr->viscosity() << endl;
                ffGY  << setw(a) << left << T << tr->viscosityGY() << endl;
		f15 << setw(a2) << left << T;
		f16 << setw(a2) << left << T;
		f15 << setw(a2) << left << gas->enthalpy_mass();
		f15 << setw(a2) << left << gas->intEnergy_mass();
		f15 << setw(a2) << left << gas->entropy_mass();
		f15 << setw(a2) << left << gas->cp_mass() << endl;
		f16 << setw(a2) << left << gas->enthalpy_mole();
		f16 << setw(a2) << left << gas->entropy_mole() << endl;
//		ci  << setw(a)  << left << T << mmColl.omega11(1.5,0.0) << endl;//tr->integrals.omega11;
		m1  << setw(a) << left << T << massConstrain << endl;
                ch1  << setw(a) << left << T << chargeConstrain << endl;



}


//	file.close();
        file2.close();
	delete gas;
	delete gas2;

	f.close();
	f10.close();
	f10e.close();
	f15.close();
	f16.close();
	fa.close();
	fa2.close();
	fb.close();
	fd.close();
	fe.close();
        fe2.close();
        fe3.close();
        ff.close();
        ffGY.close();
//	ci.close();
	bdc.close();
	bdc1.close();
	bdc2.close();
	bdc3.close();
	d1.close();
        d2.close();
        d3.close();

	m1.close();
	ch1.close();
	
	qR.close();
	qj.close();
        qj2.close();
        qj3.close();

	sV.close();
/*
        delete gas;
        delete gas2;
*/

}
 
int main() {


/*
// decomment to see the elapsed time for several iterations
	try {

        clock_t time;
        time = clock();

	for (int i=0; i<10; i++)
	{
        equil_demo();
	}


        time = clock() - time;
        cout << "Elapsed time: " << ((double)time)/CLOCKS_PER_SEC << endl;


        return 0;
    }
*/



//original
    try {

	clock_t time;
        time = clock();

        equil_demo();

	time = clock() - time;
        cout << "--------------------------------" << endl << "Elapsed time: " << ((double)time)/CLOCKS_PER_SEC << endl << "--------------------------------" << endl;
	cout << endl << "Pressure:   " << 1.0*OneAtm << endl << endl;

	return 0;
    }



    catch (CanteraError) {
        showErrors(cout);
	cout << "terminating ... " << endl;
	appdelete();
	return 1;
    }
}
